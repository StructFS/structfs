//! Random number generation store.

use std::collections::BTreeMap;

use rand::Rng;
use uuid::Uuid;

use structfs_core_store::{Error, NoCodec, Path, Reader, Record, Value, Writer};

/// Store for random number generation.
pub struct RandomStore;

impl RandomStore {
    pub fn new() -> Self {
        Self
    }

    fn read_value(&self, path: &Path) -> Result<Option<Value>, Error> {
        if path.is_empty() {
            let mut map = BTreeMap::new();
            map.insert(
                "u64".to_string(),
                Value::String("Random 64-bit unsigned integer".to_string()),
            );
            map.insert(
                "uuid".to_string(),
                Value::String("Random UUID v4".to_string()),
            );
            map.insert(
                "bytes".to_string(),
                Value::String(
                    "Write {\"count\": N} to get base64-encoded random bytes".to_string(),
                ),
            );
            return Ok(Some(Value::Map(map)));
        }

        if path.len() != 1 {
            return Ok(None);
        }

        match path[0].as_str() {
            "u64" => {
                let value: u64 = rand::thread_rng().gen();
                // u64 can exceed i64 max, so we store as string for safety
                Ok(Some(Value::String(value.to_string())))
            }
            "uuid" => {
                let uuid = Uuid::new_v4();
                Ok(Some(Value::String(uuid.to_string())))
            }
            _ => Ok(None),
        }
    }
}

impl Default for RandomStore {
    fn default() -> Self {
        Self::new()
    }
}

impl Reader for RandomStore {
    fn read(&mut self, from: &Path) -> Result<Option<Record>, Error> {
        Ok(self.read_value(from)?.map(Record::parsed))
    }
}

impl Writer for RandomStore {
    fn write(&mut self, to: &Path, data: Record) -> Result<Path, Error> {
        if to.len() != 1 {
            return Err(Error::Other {
                message: "Invalid random path".to_string(),
            });
        }

        match to[0].as_str() {
            "bytes" => {
                let value = data.into_value(&NoCodec)?;

                let count = match &value {
                    Value::Map(map) => {
                        if let Some(Value::Integer(c)) = map.get("count") {
                            *c as usize
                        } else {
                            return Err(Error::Other {
                                message: "bytes requires 'count' field".to_string(),
                            });
                        }
                    }
                    _ => {
                        return Err(Error::Other {
                            message: "bytes requires a map with 'count' field".to_string(),
                        });
                    }
                };

                if count > 1024 * 1024 {
                    return Err(Error::Other {
                        message: "Cannot generate more than 1MB of random bytes".to_string(),
                    });
                }

                let mut bytes = vec![0u8; count];
                rand::thread_rng().fill(&mut bytes[..]);

                let encoded =
                    base64::Engine::encode(&base64::engine::general_purpose::STANDARD, &bytes);

                // Return the base64 string as the path (workaround for returning data from write)
                Path::parse(&encoded).map_err(|_| Error::Other {
                    message: "Generated bytes resulted in invalid path".to_string(),
                })
            }
            _ => Err(Error::Other {
                message: format!("Cannot write to random/{}", to[0]),
            }),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use structfs_core_store::path;

    #[test]
    fn read_uuid() {
        let mut store = RandomStore::new();
        let record = store.read(&path!("uuid")).unwrap().unwrap();
        let value = record.into_value(&NoCodec).unwrap();
        match value {
            Value::String(s) => {
                assert_eq!(s.len(), 36);
                assert_eq!(&s[14..15], "4"); // Version 4
            }
            _ => panic!("Expected string"),
        }
    }

    #[test]
    fn read_u64() {
        let mut store = RandomStore::new();
        let record = store.read(&path!("u64")).unwrap().unwrap();
        let value = record.into_value(&NoCodec).unwrap();
        match value {
            Value::String(s) => {
                s.parse::<u64>().expect("Should be valid u64");
            }
            _ => panic!("Expected string"),
        }
    }
}
